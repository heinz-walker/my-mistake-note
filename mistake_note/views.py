import csv
import io
import json
import random
import google.generativeai as genai
from django.conf import settings
from django.http import JsonResponse
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.views.decorators.http import require_POST
from django.db.models import Count, Q, F, FloatField
from django.db.models.functions import TruncDay
from django.db.models.expressions import ExpressionWrapper
from fuzzywuzzy import fuzz
from django.db import transaction

from .models import Question, UserAnswer, Exam, Category, Tag
from .forms import QuestionForm, AnswerForm, QuizSelectionForm


def dashboard(request):
    # Ï†ÑÏ≤¥ Ï†ïÎãµÎ•† Í≥ÑÏÇ∞
    total_answers = UserAnswer.objects.count()
    correct_answers = UserAnswer.objects.filter(is_correct=True).count()
    overall_accuracy = (correct_answers / total_answers * 100) if total_answers > 0 else 0

    # ÏùºÎ≥Ñ Ï†ïÎãµÎ•† Ï∂îÏù¥ (Í∑∏ÎûòÌîÑÏö© Îç∞Ïù¥ÌÑ∞)
    daily_stats = UserAnswer.objects.annotate(
        day=TruncDay('submitted_at')
    ).values('day').annotate(
        correct=Count('id', filter=Q(is_correct=True)),
        total=Count('id')
    ).order_by('day')

    # Chart.jsÍ∞Ä ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎäî ÌòïÌÉúÎ°ú Îç∞Ïù¥ÌÑ∞ Í∞ÄÍ≥µ
    daily_accuracy_data = {
        "labels": [stat['day'].strftime('%m-%d') for stat in daily_stats],
        "data": [(stat['correct'] / stat['total'] * 100) for stat in daily_stats]
    }

    # Í∞ÄÏû• ÎßéÏù¥ ÌãÄÎ¶∞ Ïπ¥ÌÖåÍ≥†Î¶¨ TOP 5 (Í∑∏ÎûòÌîÑÏö© Îç∞Ïù¥ÌÑ∞)
    weak_categories = UserAnswer.objects.filter(is_correct=False) \
                          .values('question__category__name') \
                          .annotate(wrong_count=Count('id')) \
                          .order_by('-wrong_count')[:5]

    weak_categories_data = {
        "labels": [cat['question__category__name'] for cat in weak_categories],
        "data": [cat['wrong_count'] for cat in weak_categories]
    }

    # Í∞ÄÏû• ÎßéÏù¥ ÌãÄÎ¶∞ ÌÉúÍ∑∏ TOP 5 (Í∑∏ÎûòÌîÑÏö© Îç∞Ïù¥ÌÑ∞)
    weak_tags = UserAnswer.objects.filter(is_correct=False) \
                    .values('question__tags__name') \
                    .annotate(wrong_count=Count('id')) \
                    .order_by('-wrong_count')[:5]

    weak_tags_data = {
        "labels": [tag['question__tags__name'] for tag in weak_tags],
        "data": [tag['wrong_count'] for tag in weak_tags]
    }

    context = {
        'total_answers': total_answers,
        'correct_answers': correct_answers,
        'overall_accuracy': overall_accuracy,
        'daily_accuracy_data': daily_accuracy_data,
        'weak_categories_data': weak_categories_data,
        'weak_tags_data': weak_tags_data,
    }
    return render(request, 'mistake_note/dashboard.html', context)
# Ìôà ÌôîÎ©¥
def home(request):
    recent_questions = Question.objects.all().order_by('-created_at')[:5]
    context = {'recent_questions': recent_questions}
    return render(request, 'mistake_note/index.html', context)


# ÏãúÌóòÎ≥Ñ Ïπ¥ÌÖåÍ≥†Î¶¨ API
def category_by_exam(request, exam_id):
    categories = list(Category.objects.filter(exam_id=exam_id).values('id', 'name'))
    return JsonResponse(categories, safe=False)


# ÎãµÏïà Ï†ïÍ∑úÌôî Ìï®Ïàò
def normalize_answer(answer_string):
    return sorted([part.strip() for part in answer_string.split(',')])


# Î¨∏Ï†ú Ï∂îÍ∞Ä Î∞è CSV Í∞ÄÏ†∏Ïò§Í∏∞
def add_question_page(request):
    if request.method == 'POST':
        if 'import_csv' in request.POST:
            csv_file = request.FILES.get('csv_file')
            if not csv_file:
                messages.error(request, 'ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.')
                return redirect('mistake_note:add_question_page')

            # Ïù∏ÏΩîÎî© Ïò§Î•ò Î∞©ÏßÄÎ•º ÏúÑÌï¥ utf-8-sigÎ°ú ÎîîÏΩîÎî©
            data_set = csv_file.read().decode('utf-8-sig').splitlines()

            # üëá CSV ÎåÄÏã† TSVÎ•º ÏÇ¨Ïö©ÌïòÎèÑÎ°ù delimiter='\t' ÏòµÏÖò Ï∂îÍ∞Ä
            csv_reader = csv.DictReader(data_set, delimiter='\t')

            imported_count = 0
            errors = []

            try:
                with transaction.atomic():
                    for row in csv_reader:
                        exam_name = row.get('exam')
                        category_name = row.get('category')

                        if not exam_name or not category_name:
                            errors.append(f"Ïò§Î•ò: 'exam' ÎòêÎäî 'category' ÌïÑÎìúÍ∞Ä ÎπÑÏñ¥ÏûàÎäî ÌñâÏù¥ ÏûàÏäµÎãàÎã§.")
                            continue

                        exam, created_exam = Exam.objects.get_or_create(name=exam_name)
                        category, created_category = Category.objects.get_or_create(exam=exam, name=category_name)

                        question_data = {
                            'type': row.get('type'),
                            'exam': exam,
                            'category': category,
                            'content': row.get('content'),
                            'passage': row.get('passage'),
                            'correct_answer': row.get('correct_answer'),
                            'options': row.get('options'),
                            'explanation': row.get('explanation'),
                        }

                        form = QuestionForm(question_data)
                        if form.is_valid():
                            form.save()
                            imported_count += 1
                        else:
                            errors.append(f"Î¨∏Ï†ú: {row.get('content')} - Ïò§Î•ò: {form.errors.as_text()}")

                if errors:
                    for error_msg in errors:
                        messages.error(request, error_msg)
                    messages.warning(request, f"{imported_count}Í∞úÏùò Î¨∏Ï†úÎ•º ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Í∞ÄÏ†∏ÏôîÏßÄÎßå, {len(errors)}Í∞úÏùò Î¨∏Ï†úÍ∞Ä Ïã§Ìå®ÌñàÏäµÎãàÎã§.")
                else:
                    messages.success(request, f"{imported_count}Í∞úÏùò Î¨∏Ï†úÎ•º ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Í∞ÄÏ†∏ÏôîÏäµÎãàÎã§.")

            except Exception as e:
                messages.error(request, f"ÌååÏùº Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {e}")

            return redirect('mistake_note:add_question_page')
        else:
            form = QuestionForm(request.POST, request.FILES)
            if form.is_valid():
                question = form.save(commit=False)
                options_list = [v for k, v in request.POST.items() if k.startswith('option_') and v]
                question.options = ','.join(options_list)
                question.save()

                new_tags_str = form.cleaned_data.get('new_tags', '')
                if new_tags_str:
                    tag_names = [name.strip() for name in new_tags_str.split(',') if name.strip()]
                    for tag_name in tag_names:
                        tag, created = Tag.objects.get_or_create(name=tag_name)
                        question.tags.add(tag)

                form.save_m2m()

                messages.success(request, 'Î¨∏Ï†úÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.')
                return redirect('mistake_note:question_list')
            else:
                return render(request, 'mistake_note/add_question.html', {'form': form})
    else:
        form = QuestionForm()
    return render(request, 'mistake_note/add_question.html', {'form': form})


# Î¨∏Ï†ú Î™©Î°ù
def question_list(request):
    questions = Question.objects.all().order_by('-created_at')
    return render(request, 'mistake_note/question_list.html', {'questions': questions})


# Î¨∏Ï†ú ÏÉÅÏÑ∏ (Îã®Ïùº Î¨∏Ï†ú ÌíÄÏù¥)
def question_detail(request, pk):
    question = get_object_or_404(Question, pk=pk)

    # POST ÏöîÏ≤≠ (ÎãµÏïà Ï†úÏ∂ú) Ï≤òÎ¶¨
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            user_answer = data.get('user_answer', "")
        except json.JSONDecodeError:
            user_answer = request.POST.get('submitted_answer', "")

        is_correct = False
        if question.type == 'MA':
            is_correct = (normalize_answer(user_answer) == normalize_answer(question.correct_answer))
        elif question.type == 'SA':
            similarity_score = fuzz.ratio(user_answer.strip(), question.correct_answer.strip())
            is_correct = similarity_score >= 85
        else:  # MCQ
            is_correct = (user_answer.strip() == question.correct_answer.strip())

        UserAnswer.objects.create(question=question, submitted_answer=user_answer, is_correct=is_correct)
        return JsonResponse({'status': 'success', 'is_correct': is_correct})

    # GET ÏöîÏ≤≠ (ÌéòÏù¥ÏßÄ ÌëúÏãú) Ï≤òÎ¶¨
    options = [opt.strip() for opt in question.options.split(',') if opt]
    random.shuffle(options)

    alphabet = "abcdefghijklmnopqrstuvwxyz"
    options_with_labels = [{'label': alphabet[i], 'text': opt} for i, opt in enumerate(options)]

    next_question = Question.objects.filter(id__gt=pk).order_by('id').first()
    next_question_pk = next_question.id if next_question else None

    context = {
        'question': question,
        'options_with_labels': options_with_labels,
        'next_question_pk': next_question_pk,
    }
    return render(request, 'mistake_note/question_detail.html', context)


# Î¨∏Ï†ú Í≤∞Í≥º
@login_required
def quiz_result(request, quiz_id):
    quiz = get_object_or_404(Quiz, pk=quiz_id)
    attempt = get_object_or_404(QuizAttempt, user=request.user, quiz=quiz)
    questions = quiz.questions.all()

    results = []
    correct_answers_count = 0
    total_questions_count = questions.count()

    for question in questions:
        user_answers = attempt.answered.filter(question=question)
        correct_answers = question.answers.filter(is_correct=True)

        is_question_correct = set(user_answers) == set(correct_answers)

        if is_question_correct:
            correct_answers_count += 1

        results.append({
            'question': question,
            'user_answers': user_answers,
            'correct_answers': correct_answers,
            'is_correct': is_question_correct,
        })

    score = (correct_answers_count / total_questions_count) * 100 if total_questions_count > 0 else 0

    context = {
        'quiz': quiz,
        'results': results,
        'score': score,
        'correct_answers_count': correct_answers_count,
        'total_questions_count': total_questions_count,
    }

    return render(request, 'mistake_note/quiz_result.html', context)


# ÌÄ¥Ï¶à ÏÑ†ÌÉù
def quiz_select(request):
    total_questions_count = Question.objects.count()
    questions_queryset = Question.objects.all()

    if request.method == 'POST':
        form = QuizSelectionForm(request.POST)
        if form.is_valid():
            exam_name = form.cleaned_data.get('exam')
            mode = form.cleaned_data.get('mode')
            count = form.cleaned_data.get('count')

            # Î™®Îì† Î¨∏Ï†ú ÏÑ†ÌÉù
            if mode == 'all':
                questions_queryset = questions_queryset.order_by('?')
            # ÎßéÏù¥ ÌãÄÎ¶∞ Î¨∏Ï†ú
            elif mode == 'wrong':
                questions_queryset = questions_queryset.order_by('-incorrect_count', '?')
            # ÎßéÏù¥ Ïïà ÌíÄÏñ¥Î≥∏ Î¨∏Ï†ú
            elif mode == 'unsolved':
                questions_queryset = questions_queryset.order_by('solved_count', '?')
            # Í∞ùÍ¥ÄÏãù, Ï£ºÍ¥ÄÏãù, Î≥µÏàòÏ†ïÎãµ ÌïÑÌÑ∞ÎßÅ
            else:
                questions_queryset = questions_queryset.filter(type=mode).order_by('?')

            # ÏãúÌóò Ï¢ÖÎ•ò ÌïÑÌÑ∞ÎßÅ
            if exam_name:
                questions_queryset = questions_queryset.filter(exam__name=exam_name)

            # ÌïÑÏöîÌïú Î¨∏Ï†ú Í∞úÏàòÎßåÌÅº Ïä¨ÎùºÏù¥Ïã±
            questions_to_quiz = questions_queryset[:count]
            question_ids = [q.id for q in questions_to_quiz]

            # ÏÑ∏ÏÖòÏóê ÌÄ¥Ï¶à Ï†ïÎ≥¥ Ï†ÄÏû•
            request.session['quiz_questions'] = question_ids
            request.session['quiz_score'] = 0
            request.session['current_question_index'] = 0
            request.session['quiz_answers'] = []
            return redirect('mistake_note:quiz_take')
    else:
        form = QuizSelectionForm()

    context = {
        'form': form,
        'total_questions': total_questions_count
    }
    return render(request, 'mistake_note/quiz_select.html', context)

# ÌÄ¥Ï¶à ÌíÄÍ∏∞ (ÌéòÏù¥ÏßÄ ÌëúÏãú)
def quiz_take(request):
    question_ids = request.session.get('quiz_questions', [])
    current_index = request.session.get('current_question_index', 0)

    if current_index >= len(question_ids):
        return redirect('mistake_note:quiz_summary')

    question_id = question_ids[current_index]
    question = get_object_or_404(Question, pk=question_id)

    options = [opt.strip() for opt in question.options.split(',') if opt]
    random.shuffle(options)

    alphabet = "abcdefghijklmnopqrstuvwxyz"
    options_with_labels = [{'label': alphabet[i], 'text': opt} for i, opt in enumerate(options)]

    is_last_question = (current_index + 1) >= len(question_ids)

    context = {
        'question': question,
        'options_with_labels': options_with_labels,
        'is_last_question': is_last_question,
        'current_index': current_index + 1,
        'total_questions': len(question_ids),
    }

    return render(request, 'mistake_note/quiz_take.html', context)


# ÌÄ¥Ï¶à ÎãµÏïà Í∏∞Î°ù API
@require_POST
def record_quiz_answer(request):
    try:
        data = json.loads(request.body)
        user_answer = data.get('user_answer', "")
        question_id = data.get('question_id')

        with transaction.atomic():
            question = get_object_or_404(Question.objects.select_for_update(), pk=question_id)
            is_correct = False

            if question.type == 'SA':  # Ï£ºÍ¥ÄÏãù
                correct_answer = question.correct_answer.strip().lower()
                user_answer_normalized = user_answer.strip().lower()

                # fuzzywuzzyÎ•º ÏÇ¨Ïö©Ìï¥ 85Ï†ê Ïù¥ÏÉÅÏù¥Î©¥ Ï†ïÎãµÏúºÎ°ú Ï≤òÎ¶¨
                if fuzz.ratio(correct_answer, user_answer_normalized) >= 85:
                    is_correct = True

            else:  # Í∞ùÍ¥ÄÏãù(MCQ) Î∞è Î≥µÏàòÏ†ïÎãµ(MA)
                # ÎãµÏïàÏùÑ Ï†ïÍ∑úÌôîÌïòÏó¨ ÎπÑÍµê
                correct_answers_list = normalize_answer(question.correct_answer)
                user_answers_list = normalize_answer(user_answer)

                if correct_answers_list == user_answers_list:
                    is_correct = True

            # ÌíÄÏù¥ ÌöüÏàò Î∞è Ï†ïÎãµ ÌöüÏàò ÏóÖÎç∞Ïù¥Ìä∏
            if is_correct:
                question.correct_count += 1
            question.solved_count += 1
            question.save()

            UserAnswer.objects.create(
                question=question,
                submitted_answer=user_answer,
                is_correct=is_correct,
                quiz_mode=True
            )

        # üëá ÏïÑÎûò ÏΩîÎìúÎ•º Ï∂îÍ∞ÄÌïòÏó¨ ÏÑ∏ÏÖòÏùò Ïù∏Îç±Ïä§Î•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
        current_index = request.session.get('current_question_index', 0)
        request.session['current_question_index'] = current_index + 1

        # ÏÑ∏ÏÖòÏóê ÎãµÏïà Ï†ïÎ≥¥ÎèÑ Ï∂îÍ∞ÄÌïòÏó¨ Í≤∞Í≥º ÌéòÏù¥ÏßÄÏóê ÏÇ¨Ïö©
        if 'quiz_answers' not in request.session:
            request.session['quiz_answers'] = []
        request.session['quiz_answers'].append({
            'question_id': question.id,
            'is_correct': is_correct,
            'submitted_answer': user_answer
        })

        # ÌÄ¥Ï¶à Ï†êÏàò ÏóÖÎç∞Ïù¥Ìä∏
        if is_correct:
            request.session['quiz_score'] = request.session.get('quiz_score', 0) + 1

        return JsonResponse({'status': 'success', 'is_correct': is_correct})
    except Exception as e:
        print(f"record_quiz_answer Ìï®ÏàòÏóêÏÑú Ïò§Î•ò Î∞úÏÉù: {e}")
        return JsonResponse({'status': 'error', 'message': str(e)}, status=400)


# ÌÄ¥Ï¶à Í≤∞Í≥º ÏöîÏïΩ
def quiz_summary(request):
    # ÏÑ∏ÏÖòÏóêÏÑú ÌÄ¥Ï¶à Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    question_ids = request.session.get('quiz_questions', [])
    quiz_answers = request.session.get('quiz_answers', [])
    score = request.session.get('quiz_score', 0)

    total_questions = len(question_ids)

    # ÌãÄÎ¶∞ Î¨∏Ï†ú Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
    incorrect_questions_data = []
    for answer_data in quiz_answers:
        if not answer_data['is_correct']:
            question = get_object_or_404(Question, pk=answer_data['question_id'])
            incorrect_questions_data.append({
                'question': question,
                'submitted_answer': answer_data['submitted_answer']
            })

    # ÌÄ¥Ï¶à ÏÑ∏ÏÖò Ï†ïÎ≥¥ ÏÇ≠Ï†ú (ÏÑ†ÌÉù ÏÇ¨Ìï≠)
    # del request.session['quiz_questions']
    # del request.session['current_question_index']
    # del request.session['quiz_answers']
    # del request.session['quiz_score']

    context = {
        'score': score,
        'total_questions': total_questions,
        'incorrect_questions_data': incorrect_questions_data,
    }

    return render(request, 'mistake_note/quiz_summary.html', context)


def get_question_count(request):
    exam_name = request.GET.get('exam')
    mode = request.GET.get('mode')

    questions_queryset = Question.objects.all()

    if exam_name:
        questions_queryset = questions_queryset.filter(exam__name=exam_name)

    if mode == 'all':
        pass
    elif mode == 'wrong':
        questions_queryset = questions_queryset.filter(incorrect_count__gt=0)
    elif mode == 'unsolved':
        questions_queryset = questions_queryset.filter(solved_count=0)
    else:
        questions_queryset = questions_queryset.filter(type=mode)

    count = questions_queryset.count()
    return JsonResponse({'count': count})

@require_POST
def validate_question_api(request):
    """
    Í∏∞Ï°¥ ÏùëÎãµ Ìè¨Îß∑ÏùÑ Ïú†ÏßÄÌïòÎ©¥ÏÑú ÏïàÏ†ïÏÑ±Îßå Î≥¥Í∞ï:
    - JSON Î≥∏Î¨∏ Í≤ÄÏ¶ù
    - ÌïÑÏàò ÌïÑÎìú ÌôïÏù∏
    - ÌÉÄÏûÑÏïÑÏõÉ Ï†ÅÏö©
    - Îπà ÏùëÎãµ/ÌòïÏãù Î∂àÏùºÏπò Î∞©Ïñ¥
    - ÎÇ¥Î∂Ä ÏòàÏô∏ Î©îÏãúÏßÄ ÎÖ∏Ï∂ú ÏµúÏÜåÌôî
    ÏùëÎãµ Ïòà:
      { "status": "success", "feedback": "..." }
      { "status": "error", "message": "..." }
    """
    try:
        try:
            data = json.loads(request.body.decode("utf-8"))
        except Exception:
            return JsonResponse({"status": "error", "message": "ÏûòÎ™ªÎêú ÏöîÏ≤≠ Î≥∏Î¨∏(JSON ÏïÑÎãò)"}, status=400)

        question_content = (data.get("content") or "").strip()
        question_options = (data.get("options") or "").strip()
        question_answer  = (data.get("answer")  or "").strip()

        if not question_content or not question_answer:
            return JsonResponse({"status": "error", "message": "content/answerÎäî ÌïÑÏàòÏûÖÎãàÎã§."}, status=400)

        api_key = getattr(settings, "GEMINI_API_KEY", "")
        if not api_key:
            return JsonResponse({"status": "error", "message": "ÏÑúÎ≤ÑÏóê GEMINI_API_KEYÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§."}, status=500)

        model_name = getattr(settings, "GEMINI_MODEL", "gemini-1.5-flash")
        timeout = int(getattr(settings, "GEMINI_TIMEOUT_SEC", 12))

        genai.configure(api_key=api_key)
        model = genai.GenerativeModel(model_name)

        prompt = (
            "ÎãπÏã†ÏùÄ ÏãúÌóòÎ¨∏Ìï≠ Í≤ÄÌÜ†ÏûêÏûÖÎãàÎã§. ÏïÑÎûò Î¨∏Ìï≠Ïùò 'Î™ÖÌôïÏÑ±/Ï†ïÎãµ Ïú†ÏùºÏÑ±/ÏÑ†ÌÉùÏßÄ ÌÉÄÎãπÏÑ±'ÏùÑ Í∞ÑÍ≤∞ÌïòÍ≤å Í≤ÄÌÜ†ÌïòÍ≥† "
            "Îëê Ìï≠Î™©ÏúºÎ°úÎßå Ï∂úÎ†•ÌïòÏÑ∏Ïöî: 1) Ïú†Ìö®ÏÑ±, 2) Í∞úÏÑ† Ï†úÏïà.\n"
            f"---\n- Î¨∏Ï†ú ÎÇ¥Ïö©: {question_content}\n- ÏÑ†ÌÉùÏßÄ: {question_options}\n- Ï†ïÎãµ: {question_answer}\n---"
        )

        resp = model.generate_content(prompt, request_options={"timeout": timeout})

        # SDK Î≤ÑÏ†ÑÎ≥Ñ ÏùëÎãµ Ï∂îÏ∂ú (ÏïàÏ†Ñ)
        text = getattr(resp, "text", None)
        if not text and getattr(resp, "candidates", None):
            parts = getattr(resp.candidates[0], "content", {}).get("parts", [])
            text = "".join(getattr(p, "text", "") for p in parts)

        if not text or not str(text).strip():
            return JsonResponse({"status": "error", "message": "AI ÏùëÎãµÏù¥ ÎπÑÏñ¥ ÏûàÏäµÎãàÎã§."}, status=502)

        return JsonResponse({"status": "success", "feedback": str(text).strip()})
    except Exception:
        # ÎÇ¥Î∂Ä ÏóêÎü¨Îäî ÏÉÅÏÑ∏ ÎÖ∏Ï∂úÌïòÏßÄ ÏïäÏùå (Î≥¥Ïïà/ÏïàÏ†ïÏÑ±)
        return JsonResponse({"status": "error", "message": "AI Í≤ÄÏ¶ù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."}, status=502)

#test
